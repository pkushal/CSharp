Tutorial 1:

C# is case sensitive

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("Hello ");
            Afunction();
            
            Console.ReadLine(); //to avoid the program to self closing
        }
        static void Afunction()
        {
            Console.WriteLine("World");
        }

    }
}


Tutorial 2:

Reading and writing to console

        Console.WriteLine("Please enter your name: ");
        String userName= Console.ReadLine();
        Console.WriteLine("Hello " + userName);//Concatenating the strings
        Console.WriteLine("Hello {0}. This is using the placeholder method", userName); //Using the placeholder method

to read an int value :

Console.WriteLine("Please enter a number: ");
            int num = int.Parse(Console.ReadLine());
            Console.WriteLine("did mean :" + num);


Tutorial 3:
Built in types:

Boolean:
bool b=true;

Intergral Data types:
byte: 8 bits 0-255 unsigned
sbyte: signed byte -128 to 127
short: -32,768 to 32,767
int: -2,147,4483,648 to 2,147,4483,647   32 bits 4 bytes
long is 64 bit which is 8 bytes: signed
ulong is unsigned

To find the max and min values we can just do like:
        Console.WriteLine( int.MinValue);
        Console.WriteLine(int.MaxValue);

floating:
float: 32 bit
double: 64 bit

 string Name = "\"Kushal Pradhan is my name\"";
 Console.WriteLine(Name);

 escape character: \", \n :new line, \t tab, \\ 

 Verbatim Literal:
 It makes the code look more readable by putting the @ sign before the quotes and it will not consider the escape characters
            String link1 = "C:\\Users\\Kushal\\Documents\\Visual Studio 2013\\Projects";
            Console.WriteLine("line1: " + link1);
            String link2 = @"C:\Users\Kushal\Documents\Visual Studio 2013\Projects";
            Console.WriteLine("line2: " + link2);


The arithmetic operators, conditional, binary etc are similar to java.


?:    is called the ternary operator


Nullable types in C#:

In c#, the types are divided into 2 broad catrgories
Value Type: int, float, double,structs, enums
Reference Type: Interface, class, delegates, arrays

By default the value types are not nullable and to make it nullable we use ?

int i=0; here i cannot be set to null
if i do int?i=0; then 'i' s nullable  and i=null is legal

This is applicable while creating a form and user has no middle name and without the nullable thing, the user has to give some input
bool? married=null;
here the nullable boolean data type can store 3 different values, true, false or null
We can also do like married.Value will give the value in the married boolean variable.

Null coalescing operator:

int? TicketsOnSale = null;
    int AvailableTickets;
    if (TicketsOnSale == null)
    {
        AvailableTickets = 0;
    }
    else
    {
        AvailableTickets = (int)TicketsOnSale; // need to do the casting since the TicketsOnSale is nullable type
    }

    Console.WriteLine("Availale tickets: "+AvailableTickets);

    This code can be done using the null coalescing operator as
    int AvailableTickets=TicketsOnSale ?? 0;// this mean if the AvailableTickets is null then use the default value of 0 and use the value 
    if not null;

    Datatype Conversion:

    Implict Conversion is done automatically by the compiler when there will be no
    loss of information like converting a int to float

    While converting the float to int there will be loss of information and this is called explict conversion and we
    need to do the casting

    float f= 45.77F;
    int i=(int)f; // this is called type cast
    int j= Convert.ToInt32 (f); // this is using the convert class

    String num = "100";
    int l = int.Parse(num);
    but this will not work if we have num="100kp"; so we can do like

      String num1 = "100KP";
                
        int result = 0;
        bool sucess=int.TryParse(num1, out result); // it has boolean conversion data type
        if (sucess)
        {
            Console.WriteLine(result);
        }
        else
        {
            Console.WriteLine("Please enter a valid number")
        }



    difference between the type cast and the convert class: if I have a very big number in the float which the int cannot 
    store.. then if I do the type cast will not give the error and will instead show the least number it can store while
    the convert class will give error.

    While initializing the float we need to do like:
    float f= 1.356F; //need to suffix the number with F


    Arrays:
    Similar to java
     int[] kushal=new int[3];
     kushal[0]=1;
      and so on.

Comments:
// single line comment
/* */  for multiple line comment
/// for XML documentation


To comment do Ctrl + and K and C

To comment about the class use the /// and the summary tag as shown below

namespace ConsoleApplication1
{
    class SecondApp
    {
        static void Main(string[] args)
        {
            SampleClass
        }
    }

}
///<summary>
/// This is some info about the class
///</summary>
public class SampleClass
{

}


IF statements:
Same as Java

Switch statements:

int i=90;

switch(i)
{
    case 10:
    Console.WriteLine("haha its 10");
    break;

    // since there is not code to execute  for case 20 and 30 it will fall down to case 40 do the 
    //code in 40. This is combining the case statement

    case:20
    case:30
    case:40
        Console.WriteLine.("it is either 20 or 30 or 40");
        break;

    default:
    Console.WriteLine("haha its not 10");
    break;
}


Label:

It is like a marker

            static void Main(string[] args)
        {
            start:
            Console.WriteLine("Please enter a number: ");
            int num = int.Parse(Console.ReadLine());
            Console.WriteLine("did mean :" + num);

            switch (num)
            {
                case 10:
                    Console.WriteLine("haha its 10");
                    break;

                default:
                    Console.WriteLine("haha its not 10");
                    break;
             }
            Console.WriteLine("Do you want to continue: Y or N");
            String decision= Console.ReadLine();
            switch(decision.ToUpper())
            {
                case "Y":
                    goto start;
    
                default:
                    Console.WriteLine("Bye");
                    break;

               }
               Console.ReadLine();
        }


While loop:

int start=0;
while(start<=10){
    Console.WriteLine(start);
    start++;
}


do While loops:

do{
   something 
}while(some condition is true);


For Loop:

for (int j = 0; j < 10; j++)
            {
                Console.WriteLine(j*2);
            }


For each:

   int[] numbers={1,2,3};

           
            foreach(int k in numbers){
                Console.WriteLine(k);
            }


break and continue:

break will get out of the loop.
continue will just skip the statements below the continue and start with the new loop cycle

for(int i=0; i<20;i++){
    if(i%2==0)
        continue;

    Console.WriteLine(i);
}
// this for will skip the even numbers


Methods in C#:
------------------------
access_modifiers return_type method_name(Parameters if any){
    
}

public void EvenNumbers(){
                Console.WriteLine("this is from the method");
                int start=0;
                while(start<=20){
                    Console.WriteLine(start);
                    start += 2;
                }
           }

and in the main method, instantiate the Class's object and invoke the method in it.



Method Parameters:
-----------------------------
Pass by value:

    class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            simpleMethod(i);
            Console.WriteLine(i);
            Console.ReadLine();

        }
        public static void simpleMethod(int j)
        {
            j = 101;
        }
    }
This will print out the value i =0;


Pass by reference:
class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            simpleMethod(ref i);
            Console.WriteLine(i);
            Console.ReadLine();

        }
        public static void simpleMethod(ref int j)
        {
            j = 101;
        }
    }

    This will give the value of i to be 101. This is passing by reference, pointing to the same memory location.
    Java is always pass-by-value. To change the value or do the pass by reference kinda thing, you have to use the getter and setter.

    Returning Multiple values from a method:
    ----------------------------------------

Normal thing:
    public static int Calculate(int a, int b)
        {
            return a + b;
        }

Now the magic:


  public static void Calculate(int a, int b,out int sum, out int product)
        {
            sum= a + b;
            product = a * b;
        }
And inside the  main method we can do like:

            int total=0;
            int product=0;
            Calculate(5, 2, out total, out product);
            Console.WriteLine("Sum: " + total + " product: " + product);


Param keyword:
public static void paramMethods(params int[] a){
            Console.WriteLine("Length of the given array is: "+a.Length);
            foreach(int val in a){
                Console.WriteLine(val);
            }


and in the main method we can do like:

int[] a={1,2,4};
paramMethods(a);

With param keyword in the method signature, we can also do like paramMethods(); 
It will not give any errror. But if there is not param keyword in the method signature
it will give error if you call paramMethods();


You Cannot have more than one param keyword in  the method signature and it should be the last parameter if 
you have multiple parameters for the method.
paramMethods(6,7,8); is also a way to give input as the array.

Differece between method parameters and method arguments:

int i=9;
kushal(i);

public static void kushal(int j){
    //do something
}

Here j is called the method paramethod and  i the method argument


Namespaces in C#:
------------------

help you organize the program.

namespace ProjectA
{
//this namespace will have all the codes from teamA and teamB for the same project called ProjectA.
    namespace TeamA
    {
    // put all the classes from team A
        public class Kushal{

        }
    }    
    namespace TeamB
    {
    // put all the classes from team B
        public class Pradhan{

        }
    }
}


Say to use the class from teamA we can do like;
ProjectA.TeamA.Kushal // this is fully qualified naming method
or do like

using ProjectA.TeamA on top and just call Kushal.somemethod();

using the alias:
using way = abc.def.gkj ;
using path = kjk.lkjk.lkjl.kljj;

then we can use the way and wala alias to call the classes and invoke on the methods as way.Kushal.print();

Nesting the namespace:
namespace A.B {} is equivalent to

namespace A
{
    namespace B
    {
     // do something
    }    
}





Class:
----------
behavoiur = methods
field = data is also referred to as state


namespace CSharpClasses
{
    class Customer
    {
        string _firstName;
        string _lastName;
        
        // Constructor
        public Customer(string FirstName, string LastName)
        {
            this._firstName = FirstName; // this keyword is for better readability
            _lastName = LastName;
        }
        public void PrintFullName()
        {
            Console.WriteLine("Full Name = {0}", _firstName + " " + _lastName);
            Console.ReadLine();

        }
        //destructors: don't take parameters...don't need destructors..we don't have to call them..works automatically
        ~Customer()
        {
            //Clean up code here
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Customer c1 = new Customer("Kushal", "Pradhan");
            c1.PrintFullName();
        }
    }
}


  //this is for when we don't have the name is provided like a default consctructor
        public Customer()
            : this("NO first name entered ", "NO last name provided ")
        {
        }

This is called constructor overLoading. We have more than one constructor depending upon the input type.




Static and Instance Class members:
------------------------------------
there is either static or non-static(instance) for states or behaviours
We make something static if it doesn't change with object and reamins constant

Constructors can also be static and access modifier is not allowed in the static constructor.
If we don't put the public access modifier in the normal constructor then we will not be able to use it outside the class.
However we will not need public access modifier for the static constructors...static constructor need not be called.

We need static constructor for initializing the static fields.

instance members belongs to objects and static members belongs to class.
static constructot will be called only once while instance constructors will be called every time.

namespace CircleClass
{
    class Circle
    {   
        //these are states
        static float _PI; //this is static field, we make this static because it doesn't change
        int _Radius; // this is an instance field, since there is no static field infront of it.

        //Constructor
        public Circle(int Radius) // this will be called every time we do new.
        {
            this._Radius = Radius;
        }
        static Circle(){ //this will be called only once and are called before the instance constructors
            Circle._PI =3.141F;
        }
        
        static void Print()
        {
            //some codes
        }
        public float CalculateArea()
        {
            return Circle._PI * this._Radius * this._Radius;// NO this for static members, it doesn't belong to any object; it is common
                                                            //But we can do like Circle._PI
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Circle c = new Circle(2);
            Console.WriteLine("The area is {0}",c.CalculateArea());
            Circle c2 = new Circle(6);
            Console.WriteLine("The area is {0}", c2.CalculateArea());
            //we cannot do c.Print(); 
            //Just do like Print();
            Console.ReadLine();
        }
    }
}



Inheritance:
---------------
helps avoid duplication. abstract away the common codes, code reuse.. less errors

Inheritance, Encapsulation, Abstraction and Polymorphism.
public class ParentClass
{
    // some code    
}
public class DerivedClass: ParentClass
{
    some code
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Inheritance
{

    public class Employee
    {
        public string FirstName;
        public string LastName;
        public string email;
        public void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class FullTimeEmployee : Employee
    {
       public float YearlySalary;
    }
    public class PartTimeEmployee : Employee
    {
        public float HourlyRate;
    }
    class Program
    {
        static void Main(string[] args)
        {
            FullTimeEmployee fte = new FullTimeEmployee();
            fte.FirstName = "Kushal";
            fte.LastName = "Pradhan";
            fte.email = "kushal.pdn@gmail.com";
            fte.YearlySalary=120000;
            fte.PrintFullName();

            PartTimeEmployee pte = new PartTimeEmployee();
            pte.FirstName = "Aman";
            pte.LastName = "Khatru";
            pte.email = "amankhatri7@gmail.com";
            pte.HourlyRate = 120000;
            pte.PrintFullName();
            Console.ReadLine();
        }
    }
}


C# supports only supports single class inheritance however multilevel inheritance is possible (B inherits from A, C inherits from B).
C# supports multiple interface

Suppose we have to constructors in the parent class and we want the base class to inherit from the specific constructor then we can do like:

public class ParentClass
{
    //this is the default constructor
    public ParentClass()
    {
    Console.WriteLine("Parent constructor called");
    }

    //second constructor
    public ParentClass(string msg)
    {
        Console.WriteLine(msg);
    }
}

public class ChildClass: ParentClass
{
    public ChildClass(): base("Message class controlling the parent class")
    {
        Console.WriteLine("Child class Constructor called");
    }
}



Method Hiding:
----------------
Instead of super we have base here.
If we override the method from the base class in the child class then it will hide the base class method and run the method on child class.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MethodHiding
{

    public class Employee
    {
        public string FirstName;
        public string LastName;
        public string email;
        public void PrintFullName()
        {
            Console.WriteLine("This is from base class "+FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class FullTimeEmployee : Employee
    {
        public float YearlySalary;
        public new void PrintFullName() // we put a new  in the method to tell that we want to hide this method in parent class
        {
            Console.WriteLine("This is from the derived class: " + FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class PartTimeEmployee : Employee
    {
        public float HourlyRate;
        public new void PrintFullName()
        {
            base.PrintFullName();
            //Console.WriteLine("This is from the derived class: "+FirstName + " " + LastName + " Email: " + email);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            FullTimeEmployee fte = new FullTimeEmployee();
            fte.FirstName = "Kushal";
            fte.LastName = "Pradhan";
            fte.email = "kushal.pdn@gmail.com";
            fte.YearlySalary = 120000;
            fte.PrintFullName();
            ((Employee)fte).PrintFullName(); // fte is casted into employee and then printFullName is invoked in employee type

            PartTimeEmployee pte = new PartTimeEmployee();
            pte.FirstName = "Aman";
            pte.LastName = "Khatru";
            pte.email = "amankhatri7@gmail.com";
            pte.HourlyRate = 120000;
            pte.PrintFullName();


            Employee kpp = new FullTimeEmployee();
            kpp.FirstName = "KPP";
            kpp.LastName = "Pdn";
            kpp.email = "kushal@gmail.com";
            kpp.PrintFullName();

            Console.ReadLine();
        }
    }
}





Polymorphism:
---------------


To override the method in the child class, we need to use the virtual keyword in the method in the base class and in the child class
we neeed to use the override method in the method in the child class


namespace Polymorphism
{
    public class Employee{
        public string FirstName="FN";
        public string LastName = "LN";
        public virtual void PrintFullName() // virtual indicates that the derived class can override this method
        {
            Console.WriteLine(FirstName + " " + LastName);
        }

    }
    public class FullTimeEmployee : Employee
    {
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName +" Full time");
        }
    }
    public class PartTimeEmployee : Employee
    {
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Part time");
        }
    }
    public class TemporaryEmployee : Employee
    {
        // If we don't have the PringFullName() here then it will use the base class PrintFullName method.
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Temp time");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Employee[] employees = new Employee[4];
            employees[0] = new Employee();
            employees[1] = new PartTimeEmployee();
            employees[2] = new FullTimeEmployee();
            employees[3] = new TemporaryEmployee();

            foreach (Employee e in employees)
            {
                e.PrintFullName();
            }
            Console.ReadLine();
        }
    }
}


Polymorphism allows you to invoke the derived class method using the base class reference variable at run time. 



Method Overriding  Vs. Method Hiding:
------------------------------------------

In method overriding a base class reference variable pointing to a child class object, will invoke the overridden  method in the child class.
In method hiding, a base class reference variable pointing to a child class object, will invoke the hidden method in the base class.

Overriding:
-------------

 public class BaseClass
    {
        public virtual void Print()
        {
            Console.WriteLine("I am a base Class Print Method");
        }
    }
    public class DerivedClass : BaseClass
    {
        public override void Print()
        {
            Console.WriteLine("I am a Derived Class Print Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BaseClass b = new DerivedClass();
            b.Print(); // this will print (I am a Derived Class Print Method)
            DerivedClass d = new DerivedClass();
            d.Print(); // this will print (I am a Derived Class Print Method)
            Console.ReadLine();
        }
    }

Method hiding:
------------------

 public class BaseClass
    {
        public virtual void Print()
        {
            Console.WriteLine("I am a base Class Print Method");
        }
    }
    public class DerivedClass : BaseClass
    {
        public new void Print()
        {
            Console.WriteLine("I am a Derived Class Print Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BaseClass b = new DerivedClass();
            b.Print();  // this will print (I am a Base Class Print Method)
            DerivedClass d = new DerivedClass();
            d.Print();  // this will print (I am a Derived Class Print Method)
            Console.ReadLine();
        }
    }


    Method Overloading:
    ------------------------

    Function overloading is interchangably used with method overloading.
    It allows a class to have multiple method with the same name, but with different signature. SO it can be done based on 
    the number, type(int, float) or kind(value, Ref, Out) of parameters.
    However it is not possible to overload a method just using the return type and params modifier.


namespace MethodOverLoading
{
    class Program
    {
        public static void Add(int FN, int SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(float FN, float SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(int FN, float SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(int FN, int SN, int TN)
        {
            Console.WriteLine("Sum ={0}", FN + SN);
        }
        public static void Add(int FN, int SN, out int Sum)
        {
            Console.WriteLine("Sum ={0}", FN + SN);
            Sum = FN + SN;
        }
        static void Main(string[] args)
        {
            Add(1, 2);
            Console.ReadLine();
        }
    }
}


Properties:
-------------


Marking the field public is a bad idea. It can be easily changed..do not expose the fields as public...make them private
By convention , we declare the names of the private fields using the underscore as private int _id;
We need to use the getter and setters to encapsulate  and protect fields. But in c# we can use the properties instead of 
using the getter and setters.

Usual way:
-----------

namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;

        public void setId(int id)
        {
            this._Id = id;
        }
      
        public void setName(string name)
        {
          
            this._name = name;
          
        }
        public void setPassMark(int passmark)
        {
            this._passmark = passmark;
        }
        public void print()
        {
            Console.WriteLine("ID: {0} and Name: {1} and Passmark: {2}", this._Id,this._name,this._passmark);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.setId(7787);
            s.setName("Kushal");
            s.setPassMark(40);
            s.print();
          
            
            Console.ReadLine();
        }
    }
}


The advantage of properties over traditional getter and setter is that you can access them as if they were public fields.


namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;

        public int Id
        { // it will have no parameters but will have set and get accessor
            set{
                if (value <= 0)
                {
                    throw new Exception("Student Id cannot be negative");
                }
                this._Id = value;
            }
            get{
                return this._Id;
            }
            
        }

        public string Name
        { // it will have no parameters but will have set and get accessor
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    throw new Exception("Student name cannot be negative");
                }
                this._name = value;
            }
            get
            {
                return string.IsNullOrEmpty(this._name)?"No Name":this._name;
            }

        }
        public int Passmark
        { // it will have no parameters but will have set and get accessor
           
            get
            {
                return this._passmark;
            }

        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Id = 101;
            s.Name = "kushal Properties";
          
            Console.WriteLine(s.Id + "  "+ s.Name+" "+s.Passmark);
            
            Console.ReadLine();
        }
    }
}


Auto Implemented Properties:
----------------------------
For field that have no logic like city or email we can just use the autoimplemented properties. We also donot need to declare the 
private instance variable.
 Just do as  public string Email {set;get;}...the complier will do every thing.


namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;
        

        public int Id
        { // it will have no parameters but will have set and get accessor
            set{
                if (value <= 0)
                {
                    throw new Exception("Student Id cannot be negative");
                }
                this._Id = value;
            }
            get{
                return this._Id;
            }
            
        }

        public string Name
        { // it will have no parameters but will have set and get accessor
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    throw new Exception("Student name cannot be negative");
                }
                this._name = value;
            }
            get
            {
                return string.IsNullOrEmpty(this._name)?"No Name":this._name;
            }

        }
        public int Passmark
        { // it will have no parameters but will have set and get accessor
           
            get
            {
                return this._passmark;
            }

        }
        public string City
        {
            set;
            get;
        }
        public string Email {set;get;}

    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Id = 101;
            s.Name = "kushal Properties";
            s.Email="kushal.pdn@gmail.com";
            s.City = "Tansen";
            Console.WriteLine(s.Id + "  "+ s.Name+" "+s.Passmark+ " "+s.Email + " " +s.City);
            
            Console.ReadLine();
        }
    }
}






Structs:
----------
Structs can have:
    1. Private fields
    2. public properties
    3. constructors
    4. method
 just like a class



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Structs
{
    //here everything is same as in the class..only difference is we have used struct instead of class.
    public struct Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
        public Customer(int id, string name)
        {
            this._id = id;
            this._name = name;
        }
        public void PrintDetails()
        {
            Console.WriteLine("Id: {0} and Name: {1}", this._id, this._name);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Customer c1 = new Customer(101,"Mark");
            c1.PrintDetails();

            Customer c2 = new Customer();
            c2.ID = 102;
            c2.Name = "Jake";
            c2.PrintDetails();
            Console.ReadLine();

            //this is object initializer syntax (introduced in C# 3.0)...we can use this to intitialize classes as well
            Customer c3 = new Customer
            {
                ID=103,
                Name="Aman"
            };
            c3.PrintDetails();

        }
    }
}



DIFFERENCE BETWEEN CLASS AND STRUCT:
-------------------------------------

Struct is a value type while class is reference type.
structs are stored in stack while class are stored in heap

Value type hold their value in memory where they are declared, but reference types hold a reference to an object in memory.

Value types are destroyed immediately after the scope is lost while for the reference types only the reference variable is destroyed
after the scope is lost. Object is destroyed later by the garbage collector.

When you copy one struct into another struct, a new copy of that struct is created and modification on one struct will not affect the
values contained in other struct.
On the other hand if we copy a class to another class, we only get copy of the reference variable and both the reference variable point to 
the same object on heap. So any operation on one will affect the values contained by the other reference variable.

structs cannot have destructor while class can have destructor

Class:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

    public class Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
  
      
    }
    class Program
    {
        static void Main(string[] args)
        {

            
                Customer c1 = new Customer(); 
                c1.ID = 898;
                c1.Name = "Mark";
             

                Customer c2 = c1;
                c2.Name = "wala";
                Console.WriteLine("C1.Name: {0} and C2.Name: {1}", c1.Name, c2.Name);
                // this will refer to the same object and change in name will affect both c1 and c2
          }
            int k = i;
        Console.ReadLine();

        }
    }


On the other hand:

    public struct Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
  
      
    }
    class Program
    {
        static void Main(string[] args)
        {

            
                Customer c1 = new Customer(); 
                c1.ID = 898;
                c1.Name = "Mark";
             

                Customer c2 = c1;
                c2.Name = "wala";
                Console.WriteLine("C1.Name: {0} and C2.Name: {1}", c1.Name, c2.Name);
                // this will refer to the different object and change in name will NOT affect both c1 and c2
          }
            int k = i;
         Console.ReadLine();

        }
    }
}

Structs cannot have explicit parameter less constructor where as class can.
this means:
in struct:


public struct Customer{
    public Customer(){} is not allowed while this is allowed in class
}
Struct cannot ih=nherit from another class where as class can can. Both class and structs can inherit from interface.
int, double are examples of structs in .NET framework. Struct are sealed types.

when we seal a class we cannot inherit from that.

public sealed class Customer{
    // some code
}
public class Derived : Customer is not allowed



Interface:
----------

keyword is interface. Just like classes interface also contains properties, methods, delegates or events but only declaration 
and no implementation.
They are public by default and they won't allow explicit modifiers.(Don't even put public keyword, they are public by default).
 A class  can inherit from multiple interface but not more than one class at a time. They cannot also contain field.
Interface can inherit from other interface.
We cannot insantiate from an interface but an interface reference variable can point to a derived class object.

We generally put I infront of a interface name as ICustomer.
When we implement the interface we need to put the access modifier as public.

Parent class reference variable can point to a child class object.


Explicit Interface Inplementation:
------------------------------------
Don't use the access modifiers in the explicit Inteface implementation. When two or more interface has same method signature
there will be confusion, this is the case of explicit interface implementation. and in this case we should not use the access modifier
in the interface implementation.

namespace ExplicitInterfaceImplementation
{
    interface I1
    {
        void Method1();
     }
    interface I2
    {
        void Method1();
    }
    class Program :I1,I2
    {
        void I1.Method1() // no access modifier
        {
            Console.WriteLine("I1 interface method");
        }

        void I2.Method1() // no access modifier
        {
            Console.WriteLine("I2 interface method");
        }
        static void Main(string[] args)
        {
            Program P = new Program();
            //P.Method1(); There is an ambuiguity it is invoking the I1 or I2's method
            ((I1)P).Method1(); // type casting is necessary
            ((I2)P).Method1();
            Console.ReadLine();
        }
    }
}


We can also set one interface default and other not default as:


namespace ExplicitInterfaceImplementation
{


    interface Inter
    {
        void Method2();
    }
    interface face
    {
        void Method2();
    }
    class Program :Inter,face
    {
        public void Method2()
        {
            Console.WriteLine("Default inteface method 2");
        }
        void face.Method2()
        {
            Console.WriteLine("Not so Default inteface method 2");
        }

        static void Main(string[] args)
        {
            Program P = new Program();
            P.Method2();
            ((face)P).Method2();

            Console.ReadLine();
        }
    }
}



Abstract Class in C#:
------------------------

Keyword: abstract
They are incomplete classes.Abstract methods will not have any implementation, just a signature as interface.
They cannot be instantiated. The class derived from the abstract classes has to be implemented by the child class.
Abstract classes are only used as a base classes.

If class inherits from the abstract from the abstract class, it has two options to implement the abstract method.
    1. provide implementation for all the abstract members inherited from the base abstract.
    2. If you do not wish to implement the abstract the methods, then the class has to be marked as abstract.


Abstract class cannot be sealed...sealed keyword to prevent inheriting...they contradit each other.
Absstract class may contain abstract method and fields, but not mandatory


Abstract Classes vs Interfaces:
-------------------------------

Abstract classes can have implementation of some of the members but none for interface.
Abstract classes can have fields but no for interface
Interface can inherit from another interface but not from abstract class while abstract can inherit from another
abstract class or interface.
A class can inherit from multiple interface at the same time while as class cannot from the multiple classes at the same time
Abstract class members can hava access modifier where as interface members (methods) cannot have access modifiers.


Problems with multiple Class inheritance:
------------------------------------------
Diamond problem.

Scenario:
There is a Base class A
B and C inherits from A
D inherits from B and C

                    A
            B               C
                    D

            then d will not know which method to implement, B's or D's

Gist : do not implement from the multiple class and it will also not allow that.


MultipleClass iheritance using the interfaces:
------------------------------------------------

Simple cha.. just do it.



Delegates in C#:
----------------
It is a type safe (signature should match) funtion pointer. It points to a function and when you call a the delgate, it invokes the function
Keyword: delegate
Syntax just like function....just like a method signature


using System;
using System.Collections.Generic;

namespace DelegatesInCSharp
{

    public delegate void HelloFunctionDelegate(string str);

    //this points to any method which has a void return type and take a string input
    class Program
    {
        static void Main(string[] args)
        {
            HelloFunctionDelegate del = new HelloFunctionDelegate(Hello); // we are passing in the name of the function pointer
            del("hello from delegate");
            Console.ReadLine();
        }

        public static void Hello(string str)
        {
            Console.WriteLine(str);
        }

     }
}

Why?
Delegates are similar to class, we can create an instance of it and when you do do, pass in the function name as a parameter to the 
delegate constructor and it is to this function the delegate will point to.


Delegate usage in C#:
--------------------


using System;
using System.Collections.Generic;


namespace DelegateUsage
{
    class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
        public int Experience { get; set;}

        public static void PromoteEmployee(List<Employee> employeeList)
        {
            foreach(Employee employee in employeeList){
                if(employee.Experience>=5){
                    Console.WriteLine(employee.Name+ " Promoted");
                }
            }
            
        }
        
    }
    class Program
    {
        static void Main(string[] args)
        {
            List<Employee> empList = new List<Employee>();
            empList.Add(new Employee(){ID=101,Name="Mary",Salary=5000,Experience=4});
            empList.Add(new Employee(){ID=102,Name="Jane",Salary=3000,Experience=5});
            empList.Add(new Employee(){ID=103,Name="Rob",Salary=5000,Experience=6});
            empList.Add(new Employee(){ID=104,Name="Percival",Salary=5000,Experience=2});
            empList.Add(new Employee(){ID=105,Name="Jon",Salary=7000,Experience=3});
            empList.Add(new Employee(){ID=106,Name="Dave",Salary=53000,Experience=7});
            empList.Add(new Employee(){ID=107,Name="Chris",Salary=5000,Experience=4});
            Employee.PromoteEmployee(empList);
            Console.ReadLine();

        }
    }
}
Problem with this code is it is hard coded, not flexible....with delegate we will make it flexible.


using System;
using System.Collections.Generic;


namespace DelegateUsage
{
    delegate bool IsPromotable(Employee empl);
    class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
        public int Experience { get; set;}

        public static void PromoteEmployee(List<Employee> employeeList, IsPromotable IsEligibleToPromote)
        {
            foreach(Employee employee in employeeList){
                if(IsEligibleToPromote(employee)){
                    Console.WriteLine(employee.Name+ " Promoted");
                }
            }
            
        }
             
    }
    class Program
    {
        static void Main(string[] args)
        {
            List<Employee> empList = new List<Employee>();
            empList.Add(new Employee(){ID=101,Name="Mary",Salary=5000,Experience=4});
            empList.Add(new Employee(){ID=102,Name="Jane",Salary=3000,Experience=5});
            empList.Add(new Employee(){ID=103,Name="Rob",Salary=5000,Experience=6});
            empList.Add(new Employee(){ID=104,Name="Percival",Salary=5000,Experience=2});
            empList.Add(new Employee(){ID=105,Name="Jon",Salary=7000,Experience=3});
            empList.Add(new Employee(){ID=106,Name="Dave",Salary=53000,Experience=7});
            empList.Add(new Employee(){ID=107,Name="Chris",Salary=5000,Experience=4});
            IsPromotable promotable = new IsPromotable(Promote);
                
            Employee.PromoteEmployee(empList,promotable);
            Console.ReadLine();

        }
 public static bool Promote(Employee emp)
        {
            if (emp.Experience >= 5)
            {
                return true;
            }
            else
                return false;
        }
    }
}


MultiCast Delegates:
----------------------

It is a delegate that has reference to more than one function. When you invoke the multicast delegate, all the functions the delegate
is pointing, are invoked.
2 approches:
    + or += to register a method with the delegate
    - or -= to unregister a method with the delegate

It invokes in the same order  in which they are added.
Multicast delegate are used in the  implementation of the observer design pattern and it is also called as publish/subsribe pattern.

If the delegate has a return type other than void and if the delegate is a multicast delegate, only the value of the last invoked method
will be returned. Along the same lines, if he delegate has an out parameter, the value of the output parameter, will be the value assigned by the last
method.

namespace MultiCastDelegates
{
    public delegate void SampleDelegate();
    class Program
    {
        public static void SampleMethod1()
        {
            Console.WriteLine("Sample method 1 Invoked");
        }
        public static void SampleMethod2()
        {
            Console.WriteLine("Sample method 2 Invoked");
        }
        public static void SampleMethod3()
        {
            Console.WriteLine("Sample method 3 Invoked");
        }
     
        static void Main(string[] args)
        {
            SampleDelegate del1, del2, del3, del4;
            del1 = new SampleDelegate(SampleMethod1);
            del2 = new SampleDelegate(SampleMethod2);
            del3 = new SampleDelegate(SampleMethod3);
     //     del4 = del1 + del2 + del3; //del4 is pointing to all sampleMethod1, sampleMethod2, sampleMethod3
            del4 = del1 + del2 + del3-del2;  // this will add the del2 and then removes the del2 again.
            del4();
            
            
            // Other way to use the multicast the delegate
            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            del += SampleMethod3;
            //del -= SampleMethod1;
            del();


            Console.ReadLine();
        }
    }
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MultiCastDelegates
{
    public delegate int SampleDelegate();
    class Program
    {
        public static void SampleMethod1()
        {
            
            Console.WriteLine("Sample method 1 Invoked");
            return 1;
            
        }
        public static int SampleMethod2()
        {
            Console.WriteLine("Sample method 2 Invoked");
            return 2;
        }
      
        static void Main(string[] args)
        {

            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            int  DelegateReturnedValue = del(); // it hold the value from the last invokation list
            Console.WriteLine(DelegateReturnedValue);


            Console.ReadLine();
        }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MultiCastDelegates
{
    public delegate void SampleDelegate(out int Integer);
    class Program
    {
        public static void SampleMethod1(out int num)
        {
            num = 1;
            Console.WriteLine("Sample method 1 Invoked");
            
        }
        public static void SampleMethod2(out int num)
        {
            num = 2;
            Console.WriteLine("Sample method 2 Invoked");
            
        }
      
        static void Main(string[] args)
        {

            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            int  DelegateOutparameterValue = -1;
            del(out DelegateOutparameterValue);
            Console.WriteLine(DelegateOutparameterValue);
            Console.ReadLine();
        }
    }
}





Handling Exception:
-------------------

An exception is actually a class that derives from  System.Exception class. Exception is an unforseen error that occurs when a program is running.

Message: gets a message that describes the current exception.
stack Trace: Provides the call stack to the line number in the method where the exception.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;  // Need to add this

namespace HandlingExceptions
{
    class Program
    {
        static void Main(string[] args)
        {
            StreamReader streamReader = new StreamReader(@"C:\Users\Kushal\Documents\Visual Studio 2013\Projects\README.txt");  // @ is the verbatim
            Console.WriteLine(streamReader.ReadToEnd());
            streamReader.Close();
            Console.ReadLine();
        }
    }
}


With exception handling we have:

namespace HandlingExceptions
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                StreamReader streamReader = new StreamReader(@"C:\Users\Kushal\Documents\Visual Studio 2013\Projects\README1.txt");
                Console.WriteLine(streamReader.ReadToEnd());
                streamReader.Close();
                Console.ReadLine();
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                Console.WriteLine(e.StackTrace);
                Console.ReadLine();
            }
        }
    }
}



Total code:


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace HandlingExceptions
{
    class Program
    {
        static void Main(string[] args)
        {
            StreamReader streamReader = null;
            try
            {
                streamReader = new StreamReader(@"C:\Users\Kushal\Documents\Visual Studio 2013\Projects\README1.txt");
                Console.WriteLine(streamReader.ReadToEnd());
              }
            catch(Exception e)
            {
                Console.WriteLine("Please check if the file exists");
                Console.WriteLine(e.Message);
                Console.WriteLine(e.StackTrace);
              
            }
            finally
            {
                if (streamReader != null)
                {
                    Console.WriteLine("Finally Block....streamReader was NOT null");
                    streamReader.Close();
                }
             }

            Console.WriteLine("Out of exception handling");
            Console.ReadLine();
        }
    }
}



Inner Exceptions:
------------------

The InnerException property returns the exception instance that caused the current exception.
 To Return the original exception pass it as a parameter to the constructor , of current exception.
 Always check if inner exception is not null before accessing any property of the inner
 exception object, else , you mayu get null reference exceptio. 
 To get the type of inner exception use getType() method


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace InnerException
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {

            Console.WriteLine("Enter the first Number: ");
            int FN=Convert.ToInt32(Console.ReadLine());

            Console.WriteLine("Enter the Second Number: ");
            int SN = Convert.ToInt32(Console.ReadLine());

            int result = FN /SN;
            Console.WriteLine("Result ={0}", result);
            }
            catch (Exception e)
            {
                string filepath=@"C:\Users\Kushal\Documents\Visual Studio 2013\Projects\log.txt";
                StreamWriter sw= new StreamWriter(filepath);
                sw.Write(e.GetType().Name);
                sw.Close();
                Console.WriteLine("There is a problem. Try again.");
            }
            Console.ReadLine();

        }
    }
}

Here it will write the error in the filepath.


Complete Code demonstrating the Inner Exceptions:
-------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

/*The InnerException property returns the exception instance that caused the current exception.
 To Return the original exception pass it as a parameter to the constructor , of current exception.
 Always check if inner exception is not null before accessing any property of the inner
 exception object, else , you mayu get null reference exception. 
 To get the type of inner exception use getType() method*/
namespace InnerException
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                try
                {
                    System.Console.WriteLine("Enter First Number");
                    int FN = Convert.ToInt32(System.Console.ReadLine());
                    System.Console.WriteLine("Enter Second Number");
                    int SN = Convert.ToInt32(System.Console.ReadLine());
                    int Result = FN / SN;
                    System.Console.WriteLine("Result = {0}", Result);

                }
                catch (Exception ex)
                {
                    string filePath = @"C:\Users\Kushal\Documents\Visual Studio 2013\Projects\log9.txt";
                    if (File.Exists(filePath))
                    {
                        StreamWriter streamWriter = new StreamWriter(filePath);
                        streamWriter.Write(ex.GetType().Name);
                        streamWriter.Close();
                        System.Console.WriteLine("There is a problem");

                    }
                    else
                    {
                        /*if we want to intentionally throw an expceion we use throw keyword*/
                        /*we are also throwing the original exeption ex with the new expcetion which is thrown in case file is not found*/
                        throw new FileNotFoundException(filePath + "is not present {0}", ex);

                    }

                }
            }
            catch(Exception exception)
            {
                System.Console.WriteLine("Current Exception " + exception.GetType().Name);
                if (exception.InnerException != null)
                /*Always check if inner exception is not null before accessing any property of the inner
                    exception object, else , you mayu get null reference exception. */
                {
                    System.Console.WriteLine("Inner Exception " + exception.InnerException.GetType().Name);
                }
            }
            finally
            {
                System.Console.ReadLine();
            }
            
           
            
        }
    }
}


Creating Custom Exception:
--------------------------
Only when existing exception are not sufficient to express your problem.
Exception is nothing but a class. All existing exception inherit from System.exception class.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Runtime.Serialization;

namespace CustomExceptions
{
    class Program
    {
        static void Main(string[] args)
        {
          
            try
            {
            throw new UserAlreadyLoggedInException("User is already logged in....Kushal");
            }
            catch (UserAlreadyLoggedInException e)
            {
                Console.WriteLine(e.Message);
            }
                Console.ReadLine();
            
        }
    }
}

/*create a class that derives from the System.Exception class*/
public class UserAlreadyLoggedInException : Exception
{
    public  UserAlreadyLoggedInException() : base(){}
    public  UserAlreadyLoggedInException(string message) : base(message){}
    /*Can use the inner Exception to support the inner exceptions*/
    public UserAlreadyLoggedInException(string msg, Exception innerException) : base(msg, innerException) { }
    public UserAlreadyLoggedInException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    /*If you want your exception class to run across application domains,  then the object must be serializable.*/
}
    


-----------------------------------------------------

Exception Handling Abuse:
-------------------------

Using exception  handling to implement program logical flow is bad and is termed is as exception handling abuse.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExceptionHandlingAbuse
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {

            Console.WriteLine("Please enter the numerator: ");
            int Numerator = Convert.ToInt32(Console.ReadLine());

            Console.WriteLine("Please enter the denominator: ");
            int Denominator = Convert.ToInt32(Console.ReadLine());

            int Result = Numerator / Denominator;
            Console.WriteLine("Result is {0}", Result);
            }
            catch (FormatException)
            {
                Console.WriteLine("Please enter a number: ");
            }
            catch (OverflowException)
            {
                Console.WriteLine("Number too big... {0} and {1} is allowed: ", Int32.MinValue, Int32.MaxValue);
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("Cannot divide by zero");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.ReadLine();

        }
    }
}

here are abusing the exception, below is how we need to address these exception.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExceptionHandlingAbuse
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
            Console.WriteLine("Please enter the numerator: ");
            int Numerator;
            bool IsNumeratorConversionSuccessful =  Int32.TryParse(Console.ReadLine(), out Numerator);

             if (IsNumeratorConversionSuccessful)
             {
                Console.WriteLine("Please enter the denominator: ");
                int Denominator;
                bool IsDenominatorConversionSuccessful =  Int32.TryParse(Console.ReadLine(), out Denominator);

                if (IsDenominatorConversionSuccessful && Denominator != 0)
                {
                    int Result = Numerator / Denominator;
                    Console.WriteLine("Result is {0}", Result);
                }
                else
                 {
                 if(Denominator ==0){
                     Console.WriteLine("Denominator cannot be zero");
                 }else{
                     Console.WriteLine("Denominator should be between {0} and {1} ", Int32.MinValue, Int32.MaxValue);
                 }
                }
             } else{
                 Console.WriteLine("Numerator should be between {0} and {1} ", Int32.MinValue, Int32.MaxValue);
             }}
                 catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.ReadLine();

        }
    }
}



---------------------------------------------------------

Why Enumns:
-----------

Enums are strongly typed constants. If a program uses set of integral numbers, consider replacing them with enums. Otherwise the programs will be
less readable and maintainable.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Enums
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer[] customers = new Customer[3];
            customers[0] = new Customer{
                Name= "Mark",
                Gender = 1
            };
            customers[1] = new Customer
            {
                Name = "Allen",
                Gender = 2
            };
            customers[2] = new Customer
            {
                Name = "Barney",
                Gender = 0
            };
            foreach (Customer customer in customers)
            {
                Console.WriteLine("Name = {0} && Gender {1} ", customer.Name, GetGender(customer.Gender));
            }
            Console.ReadLine();
        }
 
            public static string GetGender(int gender){
                switch (gender){
                    case 0:
                         return "unknown";
                     case 1:
                         return "male";
                     case 2:
                         return "female";
                    default:
                        return "Invalid";
                }
            }
  }

    public class Customer
    {
        //0= unknown
        //1=  known
        //2= female
        public string Name { get; set; }
        public int Gender { get; set; }
    }
}

-----


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Enums
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer[] customers = new Customer[3];
            customers[0] = new Customer{
                Name= "Mark",
                Gender = Gender.Male
            };
            customers[1] = new Customer
            {
                Name = "Allen",
                Gender = Gender.Female
            };
            customers[2] = new Customer
            {
                Name = "Barney",
                Gender = Gender.Female
            };
            foreach (Customer customer in customers)
            {
                Console.WriteLine("Name = {0} and  Gender: {1} ", customer.Name, GetGender(customer.Gender));
            }
            Console.ReadLine();
        }
 
            public static string GetGender(Gender gender){
                switch (gender){
                    case Gender.Unknown:
                         return "unknown";
                     case Gender.Male:
                         return "male";
                     case Gender.Female:
                         return "female";
                    default:
                        return "Invalid";
                }
            }
  }

    public enum Gender
    {
        Unknown,
        Male,
        Female
    }

    public class Customer
    {
        //0= unknown
        //1=  known
        //2= female
        public string Name { get; set; }
        public Gender Gender { get; set; }
    }
}
-----


This code is not so readable so we will use enums to make it more readable.

Enums are enumerations.
Explicit cast is required to convert from enums type to an integral type and vice versa.
The default underlying type of enum in int.
The default value of first element is zero, and get incremented by 1
It is possible to customize the underlying type and value
Enums are value type
enums is used to create enumerations while, Enums class contains GetValues() or GetNames() methods which can be used to list Enums underlying type and Name.


namespace EnumsUse
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] values = (int [])Enum.GetValues(typeof(Gender));
            foreach (int value in values)
            {
                Console.WriteLine(value);
            }
            string[] names = (string[])Enum.GetNames(typeof(Gender));
            foreach (string name in names)
            {
                Console.WriteLine(name);
            }
            Console.ReadLine();
        }
    }
}

public enum Gender  OR public enum Gender : short // by default it is int
{
    Unknown, Male, Female
}

If I do like unknwon=1 then it will automatically make the Male = 2 and female =3 OR  you can define yourself to all the enum variables

Conversion:

            Gender gender = (Gender)3;
            int Num = (int)Gender.Unknown;

            So enum is strongly typed.

------
    class Program
    {
        static void Main(string[] args)
        {
            Gender gender = (Gender)3;
            int Num = (int)Gender.Unknown;

            Gender gender1 = (Gender)Season.Winter;  // Casting between different enums
            Console.ReadLine();
        }
    }
}

public enum Gender
{
    Unknown =1, Male=2, Female=3
}

public enum Season
{
    Winter =1, Spring=2, Summer=3
}


--------------------------------------------------


Type and Type Members:
----------------------

Say, Customer is Type and filed, properties and methods and type members.
In general classes, structs, enums, interaface, delegate are called types and fields, properties, constructor,  methods that normally reside in 
type are called as type members.


There are 5 access modifiers:
    1. Private
    2. Protected
    3. Internal
    4. Protected Internal
    5. Public

Type members can have all the access modifiera where type can have only 2 (internal, public) of the 5 access modifiers.



TO make the codes clear we have Region the visual studio. It will group the codes in between the region.


#region kushal
    somecode here
#endregion



---------------------------------------------------

Access Modifiers:
------------------

Private members are available only within the containing type (not even derived) while public members have no restrictions.
Protected members are available within the contaiing type and to the type that derive from the containing type


    class Program
    {
        static void Main(string[] args){
            Customer c1 = new Customer();
            Console.WriteLine(c1.ID); // this is accessible but not _id.
        }
    }
    public class Customer
    {
        private int _id;
        public int ID { get; set; }
    }





    class Program : Customer
    {
        static void Main(string[] args){
            Customer c1 = new Customer();
            //c1.ID is not accessible, but we can access via the Program instance variable.
            Program p1 = new Program();
            p1.ID =104;
        }
    }
    public class Customer
    {
        protected int ID;
    }
    public class CorporateCustomer : Customer
    {
        public void PrintId()
        {
            CorporateCustomer cc = new CorporateCustomer();
            cc.ID = 101;
            base.ID = 102; // can use base or this also   
            this.ID = 103;
        }
    }

-------------------------------

/*Internal and Protected Internal
A member with internal access modifier is avaible anywhere with in the containing assembly. It's a pile time error to access, an internal
member from outside the containing assembly
Protected Internal members can be accessed by any code in the assemly in which it is declared , or from within a dferived class in another
assembly. It is a combination of protected an internal if you have understod protected an internal , this should be very easy to follow
Access Modifier: Internal : Accesibilty : Anywhere within the containing assembly
Access Modifer: Protected Internal : Accessibiity: Anywhere with in the containing assembly, and from within a derieved class in any other
assembly*/

When we compile a project asp will generate two types of files exe and dlls. Exe is for windows applications while dll is for web app or class files.

See the Access Modifiers file.

------------------------------------


Attributes: // may be this is like annotation in java
------------
Attributes allow you to add declarative information to your programs. This information can then be queried at runtime using reflection.
There are predefined attributes provided by .NET. For instance, obsolete (marks type and type members obsolete), webmethod (to expose a method as an XML webservice method)and serializable.
It is possible to customize the attribute using parameter. Attribute is a class that inherits from system.attribute base class.


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Attributes
{
    class Program
    {
        static void Main(string[] args)
        {
            Calculator.Add(new List<int> () {10, 20, 40}); // we are passing the list of integers
            Console.ReadLine();
        }
    }

    public class Calculator
    {
        [Obsolete("Use Add (List<int> Number) method instead", true)] // this give information that this method is obsolete, here true is optional and if we put false, it will give error if I try to call this method
        public static int Add(int first, int second)
        {
            return first + second;
        }

        public static int Add(List<int> Numbers)
        {
            int sum = 0;
            foreach (int num in Numbers){
                sum +=num;
            }
            return sum;
        }
    }
}



----------------------------------------------

Reflection:
------------

It is the ability of inspecting an assemblies metadata at runtime. IT is used to find all types in an assembly and/or dynamically invoke method in an assembly.

Uses:
1. When you drag and drop a button on a win forms or an asp.net application. The properties windows uses reflection to show all teh properties of the button class. So the reflection is extensively used by IDE or a UI designer.

2. Late binding can be achieved by using the reflection. It enables you to use code that is not available at compile time.


Assembly consists of two types of data, meta data (contains information about types, members of the class) and intermediate data. With reflection, it can inspect the assembly at runtime


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection; // This is added for the reflection 


namespace Reflection
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer C1 = new Customer(); // this is early binding, we are creating instance at compile time.. other is late binding.
            // late binding is done by reflection
            Type T = Type.GetType("Reflection.Customer"); // we are trying to get all the properties of the Customer class using Reflection
            //Type T = typeof(Customer); we can also do like this
            //Type T = C1.GetType() we can do this
            Console.WriteLine("Full Name :  {0}", T.FullName);
            Console.WriteLine("Just  Name :  {0}", T.Name);
            Console.WriteLine("Just the  Namespace :  {0}", T.Namespace);
            PropertyInfo[] properties = T.GetProperties();
            Console.WriteLine("\nProperties in the customer class");
            foreach (PropertyInfo prop in properties)
            {
                Console.WriteLine(prop.PropertyType.Name + "  "+ prop.Name);
            }

            Console.WriteLine("\nMethods in the customer class");
            MemberInfo[] methods = T.GetMethods();
            foreach (MethodInfo meth in methods)
            {
                Console.WriteLine(meth.ReturnType.Name + "  " + meth.Name);
            }


            Console.WriteLine("\nConstructors in the customer class");
            ConstructorInfo[] cons = T.GetConstructors();
            foreach (ConstructorInfo con in cons)
            {
                Console.WriteLine(con.ToString());
            }

            Console.ReadLine();
        }
    }
    public class Customer
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public Customer(int ID, string Name)
        {
            this.Id = ID;
            this.Name = Name;
        }
        public Customer()
        {
            this.Id = -1;
            this.Name = string.Empty;
        }
        public void PrintID()
        {
            Console.WriteLine("ID = {0}", this.Id);
        }
        public void PrintName()
        {
            Console.WriteLine("Name = {0}", this.Name);
        }
    }
}


------------------------------------


Bindings:
---------
Early and Late Bindings:

Early binding can flag  errors at runtime. With late binding there is a risk of runtime exceptions.
Early binding is much better for performance and should always be preferred. Use late binding only when with an objects that are not available at runtime.

whatever we do generally is early binding.


late binding:
--------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace Bindings
{
    class Program
    {
        static void Main(string[] args)
        {

            Customer C1 = new Customer(); // this is early binding
            string fullname = C1.GetFullName("Kushal", "Pradhan");
            Console.WriteLine("Full name is {0}", fullname);



            Assembly executingAssembly = Assembly.GetExecutingAssembly(); // getting the current executing assembly
            Type customerType = executingAssembly.GetType("Bindings.Customer"); // getting the type of the Customer class
            object customerInstance = Activator.CreateInstance(customerType); // here we are instantiating the Customer type
            MethodInfo GetFullNameMethod = customerType.GetMethod("GetFullName"); // getting the methods the Customer Class

            //parameter for the method
            string[] parameters = new string[2];
            parameters[0] = "Walla";
            parameters[1] = "Khara";

            string fullNamelateBinding = (string) GetFullNameMethod.Invoke(customerInstance,parameters); // instance and the parameters of the method
            Console.WriteLine("Late Binding Full name : {0}", fullNamelateBinding);
            // the thing is here we have not done any new and it will not show any error at compile time, if there is any
            Console.ReadLine();
        }
    }
    public class Customer
    {
        public string GetFullName(string first, string second)
        {
            return first + "  " + second;
        }
    }
}




-------------------------------------------------------
Generics:
---------
Introduced in C# 2.0.
Allows us the design classes and methods decoupled from the data types....and code can be used with any data type
Extensively used by the collection classes available in System.Collections.Generic namespace

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Generics
{
    class Program
    {
        static void Main(string[] args)
        {
            bool Equal = Calculator.AreEqual(1, 2);
            if (Equal)
            {
                Console.WriteLine("Equal");
            }
            else
            {
                Console.WriteLine("Not Equal");
            }
        }
    }
    public class Calculator
    {
        public static bool AreEqual(int Value1, int Value2)
        {
            return Value1 == Value2;
        }
    }
}


This code is very limited to int data type

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Generics
{
    class Program
    {
        static void Main(string[] args)
        {
            bool Equal = Calculator.AreEqual("A", "A");
            if (Equal)
            {
                Console.WriteLine("Equal");
            }
            else
            {
                Console.WriteLine("Not Equal");
            }
        }
    }
    public class Calculator
    {
        public static bool AreEqual(object Value1, object Value2)  % we replaced the int to object
        {
            return Value1 == Value2;
        }
    }
}

Now this method is resueable to any data type. The problem with this method is that the it requires boxing (converting value type to reference type); this unnecessay thing will degrade the performance. It will also compare 10 and "A", which doesnot makes sense. So we use generics to address these issues.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Generics
{
    class Program
    {
        static void Main(string[] args)
        {
            bool Equal = Calculator.AreEqual<string>("A", "A");
            if (Equal)
            {
                Console.WriteLine("Equal");
            }
            else
            {
                Console.WriteLine("Not Equal");
            }
        }
    }
    public class Calculator
    {
        public static bool AreEqual <T> (T Value1, T Value2)
        {
            return Value1.Equals(Value2);
        }
    }
}

here we have made the method generic, below we have made the class generic

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Generics
{
    class Program
    {
        static void Main(string[] args)
        {
            bool Equal = Calculator<string>.AreEqual("A", "A");
            if (Equal)
            {
                Console.WriteLine("Equal");
            }
            else
            {
                Console.WriteLine("Not Equal");
            }
        }
    }
    public class Calculator<T>
    {
        public static bool AreEqual(T Value1, T Value2)
        {
            return Value1.Equals(Value2);
        }
    }
}

It doesn't have to be T, we can give it any name we want.


-------------------------------------------------------------------------

Why to override, ToString() methods?

ToString will give the string representation.
We can override equals, gethash and tostring methods in .net framework

namespace ToString
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer C1 = new Customer();
            C1.FirstName = "Kushal";
            C1.LastName = "Pradhan";
            Console.WriteLine(C1.ToString());
        }
    }
    public class Customer
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public override string ToString()
        {
            return FirstName +" "+ LastName;
        }
    }
}


----------------------------------------------------------------------------

Equals:
-------

    class Program
    {
        static void Main(string[] args)
        {
            Customer C1 = new Customer();
            C1.FirstName = "Kushal";
            C1.LastName = "Pradhan";
            Customer C2 = C1;   // here C1 and C2 are two references pointing to the same object
            Console.WriteLine(C1==C2); // this will be give true
            Console.WriteLine(C1.Equals(C2)); // this will also give true because it is comparing the references pointing to the same object

        }
    }
    public class Customer
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
    }

If we had, Customer C2 = new Customer(); 
                    C2.FirstName = "Kushal";
                    C2.LastName = "Pradhan"; 
                                             then the result will be false and false.
There is value equality but not reference equality.
== will give the reference equality
Equals will by default do the same thing as ==, but we can override to check the value equality


namespace Equals
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer C1 = new Customer();
            C1.FirstName = "Kushal";
            C1.LastName = "Pradhan";
            Customer C2 = new Customer();
            C2.FirstName = "Kushal";
            C2.LastName = "Pradhan";
            Console.WriteLine(C1==C2);
            Console.WriteLine(C1.Equals(C2));

        }
    }
    public class Customer
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        // this will do the value equality thing

        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }
            if(!(obj is Customer))
            {
                return false;
            }
            return this.FirstName == ((Customer)obj).FirstName && this.LastName == ((Customer)obj).LastName;
        }
    }
}


It is a good practise to override the getHash method as well whenever we override the equals method. So we add the following

  public override int GetHashCode()
        {
            return this.FirstName.GetHashCode() ^ this.LastName.GetHashCode();
        }



-----------------------------------------------------------

Difference between Convert.ToString() and ToString():
------------------------------------------------------

Convert.ToString() will also convert the null object to the empty string while the normal ToString() cannot do this.
This is the difference; the Convert.ToString can handle the null object and return the empty string while the other throws the null reference exception.


-----------------------------------------------------------


System.String and String.Text.StringBuilder:
--------------------------------------------

System.String is immutable while the String.Text.StringBuilder is mutable.
To use the string builder, we need to use the namespace called System.Text and we cannot just add the strings, we need to use the append methods and use toString to print the string.

using System.Text;

namespace StringTypes
{
    class Program
    {
        static void Main(string[] args)
        {
            // it is wise to use the stringBuilder when there is a heavy string manipulation
            StringBuilder userString = new StringBuilder("C#");
            userString.Append(" is good");
            userString.Append("with stringBuilder");
            Console.WriteLine(userString.ToString());
        }
    }
}


-----------------------------------------------------------

Partial Class:
--------------

Allows us to split a class into 2 or more files. All these parts are then combined into a single class, when the application is compiled. The partial keyword can also be used to split a struct or an interface over two or more files.

Visual studio uses partial classes to separate automatically generated system code  from the developer code. For instance, when you add a webform two .CS files are generated.
    webform1.aspx.cs contains the developer's code
    webform1.aspx.designer.cx contains the system generated code.

While working on large project, spreading the class over separate file allows multiple programmer to work simultaneously.


--------------------------------------------------------------


All the parts spread across different files, must use the partial keyword

All the parts spread across the different files must have the same access modifiers

If any of the parts inherit a class then the entire type inherits that class.

If any of the parts of partial class is declared abstract or sealed then the entire type is treated as abstract or sealed.

C# does not support mulitple inheritance. Different parts of the partial class must not specify different base classes.

Different parts of the partial class can specify different base interface and the final type implements all of the interfaces listed by all of the partial declaration.

Any member that are declared in a partial definition are available to all of the other parts of the partial class.


-----------------------------------------------------------


Partial Methods:
----------------
A partial class or a struct can have a partial methods
It is created using a partial keyword
The declaration consists of two parts:  
        the definition
        the implementation
        They may be in the same or in the different parts of the partial class.

The implementation of the partial method is optional
Partial methods are private by default and it will give error even if you declare it as private
It is a compile time error to include declaration and implementation at the same time for a partial method.
Return type of the partial method must be void


------------------------------------------

Indexers used in .Net:
----------------------

Indexers will have the [] brackets and we can use them to store datas.
They are like keys.
We can use the integral or the string indexers.

Indexers allows instance of a class to be indexed just like arrays.

Creating Indexers:

Use the "this" keyword to create an indexer
Just like the properties indexers have get and set accessors
Indexers can be overloaded.

namespace Indexers
{
    class Program
    {
        static void Main(string[] args)
        {
            Company company = new Company();

            Console.WriteLine("name of Employee with Id = 1 is : " +company[1]);
            Console.WriteLine("name of Employee with Id = 2 is : " + company[2]);
            company[2] = "Zaman";
            Console.WriteLine("name of Employee with Id = 2 is : " + company[2]);
        }

    }
}


namespace Indexers
{
    public class Employee
    {
        public int EmployeeId { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }

    }
    public class Company
    {
        private List<Employee> listEmployee;
        public Company()
        {
            listEmployee = new List<Employee>();
            listEmployee.Add(new Employee() { EmployeeId = 1, Name = "Kushal", Gender = "Male" });
            listEmployee.Add(new Employee() { EmployeeId = 2, Name = "Aman", Gender = "Male" });
        }

        // we are creating the indexer here
        public string this[int employeeId]
        {
            get
            {
                return listEmployee.FirstOrDefault(emp => emp.EmployeeId == employeeId).Name;
            }
            set
            {
                listEmployee.FirstOrDefault(emp => emp.EmployeeId == employeeId).Name = value;
            }
        }
    }
}



Overloading Indexers:
---------------------
Indexers can also be overloaded based on number and type of parameters.


Optional Parameters:
--------------------
Different ways that are available to make method parameters optional.

4 ways:
1. use parameters arrays
2. Method overloading
3. specify parameters defaults
4. use optionalattribute that is present in System.Runtime.InteropsService namespace

Parameter array must be the last parameter in a formal parameter list.

1.
namespace OptionalParameters
{
    class Program
    {
        static void Main(string[] args)
        {
            AddNumbers(10, 20, 30, 40);
        }
        public static void AddNumbers(int firstNumber, int secondNumber, params object[] restOfTheNumbers)
        {
            int result = firstNumber + secondNumber;
            if (restOfTheNumbers != null)
            {

                foreach (int i in restOfTheNumbers)
                {
                    result += i;
                }
            }
            Console.WriteLine("Total : " + result);
        }
    }
}


2.

namespace OptionalParameters
{
    class Program
    {
        static void Main(string[] args)
        {
            AddNumbers2(10, 20, new int[]{30, 40});
        }
  
        // we are using the method overloaded version of the AddNumbers2
        public static void AddNumbers2(int firstNumber, int secondNumber)
        {
            AddNumbers2(firstNumber, secondNumber, null);
        }

       public static void AddNumbers2(int firstNumber, int secondNumber, int[] restOfTheNumbers)
        {
            int result = firstNumber + secondNumber;
            if (restOfTheNumbers != null)
            {

                foreach (int i in restOfTheNumbers)
                {
                    result += i;
                }
            }
            Console.WriteLine("Sum : " + result);
        }
    }
}


3.

namespace OptionalParameters
{
    class Program
    {
        static void Main(string[] args)
        {
            AddNumbers3(10, 20, new int[] { 50, 40 });
        }

        //Specifying the parameters defaults
        public static void AddNumbers3(int firstNumber, int secondNumber, int[] restOfTheNumbers = null)
        {
            int result = firstNumber + secondNumber;
            if (restOfTheNumbers != null)
            {

                foreach (int i in restOfTheNumbers)
                {
                    result += i;
                }
            }
            Console.WriteLine("Grand Sum : " + result);
        }

    }
}


4.

using System.Runtime.InteropServices; // we need to import this

namespace OptionalParameters
{
    class Program
    {
        static void Main(string[] args)
        {
            AddNumbers4(10, 20, new int[] { 50, 60 });
        }

       // By using the optionalAttribute

        public static void AddNumbers4(int firstNumber, int secondNumber, [Optional] int[] restOfTheNumbers)
        {
            int result = firstNumber + secondNumber;
            if (restOfTheNumbers != null)
            {

                foreach (int i in restOfTheNumbers)
                {
                    result += i;
                }
            }
            Console.WriteLine("Grand Total : " + result);
        }

    }
}


--------------------------------------------------
