Tutorial 1:

C# is case sensitive

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("Hello ");
            Afunction();
            
            Console.ReadLine(); //to avoid the program to self closing
        }
        static void Afunction()
        {
            Console.WriteLine("World");
        }

    }
}


Tutorial 2:

Reading and writing to console

        Console.WriteLine("Please enter your name: ");
        String userName= Console.ReadLine();
        Console.WriteLine("Hello " + userName);//Concatenating the strings
        Console.WriteLine("Hello {0}. This is using the placeholder method", userName); //Using the placeholder method

to read an int value :

Console.WriteLine("Please enter a number: ");
            int num = int.Parse(Console.ReadLine());
            Console.WriteLine("did mean :" + num);


Tutorial 3:
Built in types:

Boolean:
bool b=true;

Intergral Data types:
byte: 8 bits 0-255 unsigned
sbyte: signed byte -128 to 127
short: -32,768 to 32,767
int: -2,147,4483,648 to 2,147,4483,647   32 bits 4 bytes
long is 64 bit which is 8 bytes: signed
ulong is unsigned

To find the max and min values we can just do like:
        Console.WriteLine( int.MinValue);
        Console.WriteLine(int.MaxValue);

floating:
float: 32 bit
double: 64 bit

 string Name = "\"Kushal Pradhan is my name\"";
 Console.WriteLine(Name);

 escape character: \", \n :new line, \t tab, \\ 

 Verbatim Literal:
 It makes the code look more readable by putting the @ sign before the quotes and it will not consider the escape characters
            String link1 = "C:\\Users\\Kushal\\Documents\\Visual Studio 2013\\Projects";
            Console.WriteLine("line1: " + link1);
            String link2 = @"C:\Users\Kushal\Documents\Visual Studio 2013\Projects";
            Console.WriteLine("line2: " + link2);


The arithmetic operators, conditional, binary etc are similar to java.


?:    is called the ternary operator


Nullable types in C#:

In c#, the types are divided into 2 broad catrgories
Value Type: int, float, double,structs, enums
Reference Type: Interface, class, delegates, arrays

By default the value types are not nullable and to make it nullable we use ?

int i=0; here i cannot be set to null
if i do int?i=0; then 'i' s nullable  and i=null is legal

This is applicable while creating a form and user has no middle name and without the nullable thing, the user has to give some input
bool? married=null;
here the nullable boolean data type can store 3 different values, true, false or null
We can also do like married.Value will give the value in the married boolean variable.

Null coalescing operator:

int? TicketsOnSale = null;
    int AvailableTickets;
    if (TicketsOnSale == null)
    {
        AvailableTickets = 0;
    }
    else
    {
        AvailableTickets = (int)TicketsOnSale; // need to do the casting since the TicketsOnSale is nullable type
    }

    Console.WriteLine("Availale tickets: "+AvailableTickets);

    This code can be done using the null coalescing operator as
    int AvailableTickets=TicketsOnSale ?? 0;// this mean if the AvailableTickets is null then use the default value of 0 and use the value 
    if not null;

    Datatype Conversion:

    Implict Conversion is done automatically by the compiler when there will be no
    loss of information like converting a int to float

    While converting the float to int there will be loss of information and this is called explict conversion and we
    need to do the casting

    float f= 45.77F;
    int i=(int)f; // this is called type cast
    int j= Convert.ToInt32 (f); // this is using the convert class

    String num = "100";
    int l = int.Parse(num);
    but this will not work if we have num="100kp"; so we can do like

      String num1 = "100KP";
                
        int result = 0;
        bool sucess=int.TryParse(num1, out result); // it has boolean conversion data type
        if (sucess)
        {
            Console.WriteLine(result);
        }
        else
        {
            Console.WriteLine("Please enter a valid number")
        }



    difference between the type cast and the convert class: if I have a very big number in the float which the int cannot 
    store.. then if I do the type cast will not give the error and will instead show the least number it can store while
    the convert class will give error.

    While initializing the float we need to do like:
    float f= 1.356F; //need to suffix the number with F


    Arrays:
    Similar to java
     int[] kushal=new int[3];
     kushal[0]=1;
      and so on.

Comments:
// single line comment
/* */  for multiple line comment
/// for XML documentation


To comment do Ctrl + and K and C

To comment about the class use the /// and the summary tag as shown below

namespace ConsoleApplication1
{
    class SecondApp
    {
        static void Main(string[] args)
        {
            SampleClass
        }
    }

}
///<summary>
/// This is some info about the class
///</summary>
public class SampleClass
{

}


IF statements:
Same as Java

Switch statements:

int i=90;

switch(i)
{
    case 10:
    Console.WriteLine("haha its 10");
    break;

    // since there is not code to execute  for case 20 and 30 it will fall down to case 40 do the 
    //code in 40. This is combining the case statement

    case:20
    case:30
    case:40
        Console.WriteLine.("it is either 20 or 30 or 40");
        break;

    default:
    Console.WriteLine("haha its not 10");
    break;
}


Label:

It is like a marker

            static void Main(string[] args)
        {
            start:
            Console.WriteLine("Please enter a number: ");
            int num = int.Parse(Console.ReadLine());
            Console.WriteLine("did mean :" + num);

            switch (num)
            {
                case 10:
                    Console.WriteLine("haha its 10");
                    break;

                default:
                    Console.WriteLine("haha its not 10");
                    break;
             }
            Console.WriteLine("Do you want to continue: Y or N");
            String decision= Console.ReadLine();
            switch(decision.ToUpper())
            {
                case "Y":
                    goto start;
    
                default:
                    Console.WriteLine("Bye");
                    break;

               }
               Console.ReadLine();
        }


While loop:

int start=0;
while(start<=10){
    Console.WriteLine(start);
    start++;
}


do While loops:

do{
   something 
}while(some condition is true);


For Loop:

for (int j = 0; j < 10; j++)
            {
                Console.WriteLine(j*2);
            }


For each:

   int[] numbers={1,2,3};

           
            foreach(int k in numbers){
                Console.WriteLine(k);
            }


break and continue:

break will get out of the loop.
continue will just skip the statements below the continue and start with the new loop cycle

for(int i=0; i<20;i++){
    if(i%2==0)
        continue;

    Console.WriteLine(i);
}
// this for will skip the even numbers


Methods in C#:
------------------------
access_modifiers return_type method_name(Parameters if any){
    
}

public void EvenNumbers(){
                Console.WriteLine("this is from the method");
                int start=0;
                while(start<=20){
                    Console.WriteLine(start);
                    start += 2;
                }
           }

and in the main method, instantiate the Class's object and invoke the method in it.



Method Parameters:
-----------------------------
Pass by value:

    class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            simpleMethod(i);
            Console.WriteLine(i);
            Console.ReadLine();

        }
        public static void simpleMethod(int j)
        {
            j = 101;
        }
    }
This will print out the value i =0;


Pass by reference:
class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            simpleMethod(ref i);
            Console.WriteLine(i);
            Console.ReadLine();

        }
        public static void simpleMethod(ref int j)
        {
            j = 101;
        }
    }

    This will give the value of i to be 101. This is passing by reference, pointing to the same memory location.
    Java is always pass-by-value. To change the value or do the pass by reference kinda thing, you have to use the getter and setter.

    Returning Multiple values from a method:
    ----------------------------------------

Normal thing:
    public static int Calculate(int a, int b)
        {
            return a + b;
        }

Now the magic:


  public static void Calculate(int a, int b,out int sum, out int product)
        {
            sum= a + b;
            product = a * b;
        }
And inside the  main method we can do like:

            int total=0;
            int product=0;
            Calculate(5, 2, out total, out product);
            Console.WriteLine("Sum: " + total + " product: " + product);


Param keyword:
public static void paramMethods(params int[] a){
            Console.WriteLine("Length of the given array is: "+a.Length);
            foreach(int val in a){
                Console.WriteLine(val);
            }


and in the main method we can do like:

int[] a={1,2,4};
paramMethods(a);

With param keyword in the method signature, we can also do like paramMethods(); 
It will not give any errror. But if there is not param keyword in the method signature
it will give error if you call paramMethods();


You Cannot have more than one param keyword in  the method signature and it should be the last parameter if 
you have multiple parameters for the method.
paramMethods(6,7,8); is also a way to give input as the array.

Differece between method parameters and method arguments:

int i=9;
kushal(i);

public static void kushal(int j){
    //do something
}

Here j is called the method paramethod and  i the method argument


Namespaces in C#:
------------------

help you organize the program.

namespace ProjectA
{
//this namespace will have all the codes from teamA and teamB for the same project called ProjectA.
    namespace TeamA
    {
    // put all the classes from team A
        public class Kushal{

        }
    }    
    namespace TeamB
    {
    // put all the classes from team B
        public class Pradhan{

        }
    }
}


Say to use the class from teamA we can do like;
ProjectA.TeamA.Kushal // this is fully qualified naming method
or do like

using ProjectA.TeamA on top and just call Kushal.somemethod();

using the alias:
using way = abc.def.gkj ;
using path = kjk.lkjk.lkjl.kljj;

then we can use the way and wala alias to call the classes and invoke on the methods as way.Kushal.print();

Nesting the namespace:
namespace A.B {} is equivalent to

namespace A
{
    namespace B
    {
     // do something
    }    
}





Class:
----------
behavoiur = methods
field = data is also referred to as state


namespace CSharpClasses
{
    class Customer
    {
        string _firstName;
        string _lastName;
        
        // Constructor
        public Customer(string FirstName, string LastName)
        {
            this._firstName = FirstName; // this keyword is for better readability
            _lastName = LastName;
        }
        public void PrintFullName()
        {
            Console.WriteLine("Full Name = {0}", _firstName + " " + _lastName);
            Console.ReadLine();

        }
        //destructors: don't take parameters...don't need destructors..we don't have to call them..works automatically
        ~Customer()
        {
            //Clean up code here
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Customer c1 = new Customer("Kushal", "Pradhan");
            c1.PrintFullName();
        }
    }
}


  //this is for when we don't have the name is provided like a default consctructor
        public Customer()
            : this("NO first name entered ", "NO last name provided ")
        {
        }

This is called constructor overLoading. We have more than one constructor depending upon the input type.




Static and Instance Class members:
------------------------------------
there is either static or non-static(instance) for states or behaviours
We make something static if it doesn't change with object and reamins constant

Constructors can also be static and access modifier is not allowed in the static constructor.
If we don't put the public access modifier in the normal constructor then we will not be able to use it outside the class.
However we will not need public access modifier for the static constructors...static constructor need not be called.

We need static constructor for initializing the static fields.

instance members belongs to objects and static members belongs to class.
static constructot will be called only once while instance constructors will be called every time.

namespace CircleClass
{
    class Circle
    {   
        //these are states
        static float _PI; //this is static field, we make this static because it doesn't change
        int _Radius; // this is an instance field, since there is no static field infront of it.

        //Constructor
        public Circle(int Radius) // this will be called every time we do new.
        {
            this._Radius = Radius;
        }
        static Circle(){ //this will be called only once and are called before the instance constructors
            Circle._PI =3.141F;
        }
        
        static void Print()
        {
            //some codes
        }
        public float CalculateArea()
        {
            return Circle._PI * this._Radius * this._Radius;// NO this for static members, it doesn't belong to any object; it is common
                                                            //But we can do like Circle._PI
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Circle c = new Circle(2);
            Console.WriteLine("The area is {0}",c.CalculateArea());
            Circle c2 = new Circle(6);
            Console.WriteLine("The area is {0}", c2.CalculateArea());
            //we cannot do c.Print(); 
            //Just do like Print();
            Console.ReadLine();
        }
    }
}



Inheritance:
---------------
helps avoid duplication. abstract away the common codes, code reuse.. less errors

Inheritance, Encapsulation, Abstraction and Polymorphism.
public class ParentClass
{
    // some code    
}
public class DerivedClass: ParentClass
{
    some code
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Inheritance
{

    public class Employee
    {
        public string FirstName;
        public string LastName;
        public string email;
        public void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class FullTimeEmployee : Employee
    {
       public float YearlySalary;
    }
    public class PartTimeEmployee : Employee
    {
        public float HourlyRate;
    }
    class Program
    {
        static void Main(string[] args)
        {
            FullTimeEmployee fte = new FullTimeEmployee();
            fte.FirstName = "Kushal";
            fte.LastName = "Pradhan";
            fte.email = "kushal.pdn@gmail.com";
            fte.YearlySalary=120000;
            fte.PrintFullName();

            PartTimeEmployee pte = new PartTimeEmployee();
            pte.FirstName = "Aman";
            pte.LastName = "Khatru";
            pte.email = "amankhatri7@gmail.com";
            pte.HourlyRate = 120000;
            pte.PrintFullName();
            Console.ReadLine();
        }
    }
}


C# supports only supports single class inheritance however multilevel inheritance is possible (B inherits from A, C inherits from B).
C# supports multiple interface

Suppose we have to constructors in the parent class and we want the base class to inherit from the specific constructor then we can do like:

public class ParentClass
{
    //this is the default constructor
    public ParentClass()
    {
    Console.WriteLine("Parent constructor called");
    }

    //second constructor
    public ParentClass(string msg)
    {
        Console.WriteLine(msg);
    }
}

public class ChildClass: ParentClass
{
    public ChildClass(): base("Message class controlling the parent class")
    {
        Console.WriteLine("Child class Constructor called");
    }
}



Method Hiding:
----------------
Instead of super we have base here.
If we override the method from the base class in the child class then it will hide the base class method and run the method on child class.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MethodHiding
{

    public class Employee
    {
        public string FirstName;
        public string LastName;
        public string email;
        public void PrintFullName()
        {
            Console.WriteLine("This is from base class "+FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class FullTimeEmployee : Employee
    {
        public float YearlySalary;
        public new void PrintFullName() // we put a new  in the method to tell that we want to hide this method in parent class
        {
            Console.WriteLine("This is from the derived class: " + FirstName + " " + LastName + " Email: " + email);
        }
    }
    public class PartTimeEmployee : Employee
    {
        public float HourlyRate;
        public new void PrintFullName()
        {
            base.PrintFullName();
            //Console.WriteLine("This is from the derived class: "+FirstName + " " + LastName + " Email: " + email);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            FullTimeEmployee fte = new FullTimeEmployee();
            fte.FirstName = "Kushal";
            fte.LastName = "Pradhan";
            fte.email = "kushal.pdn@gmail.com";
            fte.YearlySalary = 120000;
            fte.PrintFullName();
            ((Employee)fte).PrintFullName(); // fte is casted into employee and then printFullName is invoked in employee type

            PartTimeEmployee pte = new PartTimeEmployee();
            pte.FirstName = "Aman";
            pte.LastName = "Khatru";
            pte.email = "amankhatri7@gmail.com";
            pte.HourlyRate = 120000;
            pte.PrintFullName();


            Employee kpp = new FullTimeEmployee();
            kpp.FirstName = "KPP";
            kpp.LastName = "Pdn";
            kpp.email = "kushal@gmail.com";
            kpp.PrintFullName();

            Console.ReadLine();
        }
    }
}





Polymorphism:
---------------


To override the method in the child class, we need to use the virtual keyword in the method in the base class and in the child class
we neeed to use the override method in the method in the child class


namespace Polymorphism
{
    public class Employee{
        public string FirstName="FN";
        public string LastName = "LN";
        public virtual void PrintFullName() // virtual indicates that the derived class can override this method
        {
            Console.WriteLine(FirstName + " " + LastName);
        }

    }
    public class FullTimeEmployee : Employee
    {
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName +" Full time");
        }
    }
    public class PartTimeEmployee : Employee
    {
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Part time");
        }
    }
    public class TemporaryEmployee : Employee
    {
        // If we don't have the PringFullName() here then it will use the base class PrintFullName method.
        public override void PrintFullName()
        {
            Console.WriteLine(FirstName + " " + LastName + " Temp time");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Employee[] employees = new Employee[4];
            employees[0] = new Employee();
            employees[1] = new PartTimeEmployee();
            employees[2] = new FullTimeEmployee();
            employees[3] = new TemporaryEmployee();

            foreach (Employee e in employees)
            {
                e.PrintFullName();
            }
            Console.ReadLine();
        }
    }
}


Polymorphism allows you to invoke the derived class method using the base class reference variable at run time. 



Method Overriding  Vs. Method Hiding:
------------------------------------------

In method overriding a base class reference variable pointing to a child class object, will invoke the overridden  method in the child class.
In method hiding, a base class reference variable pointing to a child class object, will invoke the hidden method in the base class.

Overriding:
-------------

 public class BaseClass
    {
        public virtual void Print()
        {
            Console.WriteLine("I am a base Class Print Method");
        }
    }
    public class DerivedClass : BaseClass
    {
        public override void Print()
        {
            Console.WriteLine("I am a Derived Class Print Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BaseClass b = new DerivedClass();
            b.Print(); // this will print (I am a Derived Class Print Method)
            DerivedClass d = new DerivedClass();
            d.Print(); // this will print (I am a Derived Class Print Method)
            Console.ReadLine();
        }
    }

Method hiding:
------------------

 public class BaseClass
    {
        public virtual void Print()
        {
            Console.WriteLine("I am a base Class Print Method");
        }
    }
    public class DerivedClass : BaseClass
    {
        public new void Print()
        {
            Console.WriteLine("I am a Derived Class Print Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BaseClass b = new DerivedClass();
            b.Print();  // this will print (I am a Base Class Print Method)
            DerivedClass d = new DerivedClass();
            d.Print();  // this will print (I am a Derived Class Print Method)
            Console.ReadLine();
        }
    }


    Method Overloading:
    ------------------------

    Function overloading is interchangably used with method overloading.
    It allows a class to have multiple method with the same name, but with different signature. SO it can be done based on 
    the number, type(int, float) or kind(value, Ref, Out) of parameters.
    However it is not possible to overload a method just using the return type and params modifier.


namespace MethodOverLoading
{
    class Program
    {
        public static void Add(int FN, int SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(float FN, float SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(int FN, float SN)
        {
            Console.WriteLine("Sum = {0}", FN + SN);
        }
        public static void Add(int FN, int SN, int TN)
        {
            Console.WriteLine("Sum ={0}", FN + SN);
        }
        public static void Add(int FN, int SN, out int Sum)
        {
            Console.WriteLine("Sum ={0}", FN + SN);
            Sum = FN + SN;
        }
        static void Main(string[] args)
        {
            Add(1, 2);
            Console.ReadLine();
        }
    }
}


Properties:
-------------


Marking the field public is a bad idea. It can be easily changed..do not expose the fields as public...make them private
By convention , we declare the names of the private fields using the underscore as private int _id;
We need to use the getter and setters to encapsulate  and protect fields. But in c# we can use the properties instead of 
using the getter and setters.

Usual way:
-----------

namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;

        public void setId(int id)
        {
            this._Id = id;
        }
      
        public void setName(string name)
        {
          
            this._name = name;
          
        }
        public void setPassMark(int passmark)
        {
            this._passmark = passmark;
        }
        public void print()
        {
            Console.WriteLine("ID: {0} and Name: {1} and Passmark: {2}", this._Id,this._name,this._passmark);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.setId(7787);
            s.setName("Kushal");
            s.setPassMark(40);
            s.print();
          
            
            Console.ReadLine();
        }
    }
}


The advantage of properties over traditional getter and setter is that you can access them as if they were public fields.


namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;

        public int Id
        { // it will have no parameters but will have set and get accessor
            set{
                if (value <= 0)
                {
                    throw new Exception("Student Id cannot be negative");
                }
                this._Id = value;
            }
            get{
                return this._Id;
            }
            
        }

        public string Name
        { // it will have no parameters but will have set and get accessor
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    throw new Exception("Student name cannot be negative");
                }
                this._name = value;
            }
            get
            {
                return string.IsNullOrEmpty(this._name)?"No Name":this._name;
            }

        }
        public int Passmark
        { // it will have no parameters but will have set and get accessor
           
            get
            {
                return this._passmark;
            }

        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Id = 101;
            s.Name = "kushal Properties";
          
            Console.WriteLine(s.Id + "  "+ s.Name+" "+s.Passmark);
            
            Console.ReadLine();
        }
    }
}


Auto Implemented Properties:
----------------------------
For field that have no logic like city or email we can just use the autoimplemented properties. We also donot need to declare the 
private instance variable.
 Just do as  public string Email {set;get;}...the complier will do every thing.


namespace Properties
{
    public class Student
    {
        private int _Id;
        private string _name;
        private int _passmark = 35;
        

        public int Id
        { // it will have no parameters but will have set and get accessor
            set{
                if (value <= 0)
                {
                    throw new Exception("Student Id cannot be negative");
                }
                this._Id = value;
            }
            get{
                return this._Id;
            }
            
        }

        public string Name
        { // it will have no parameters but will have set and get accessor
            set
            {
                if (string.IsNullOrEmpty(value))
                {
                    throw new Exception("Student name cannot be negative");
                }
                this._name = value;
            }
            get
            {
                return string.IsNullOrEmpty(this._name)?"No Name":this._name;
            }

        }
        public int Passmark
        { // it will have no parameters but will have set and get accessor
           
            get
            {
                return this._passmark;
            }

        }
        public string City
        {
            set;
            get;
        }
        public string Email {set;get;}

    }
    class Program
    {
        static void Main(string[] args)
        {
            Student s = new Student();
            s.Id = 101;
            s.Name = "kushal Properties";
            s.Email="kushal.pdn@gmail.com";
            s.City = "Tansen";
            Console.WriteLine(s.Id + "  "+ s.Name+" "+s.Passmark+ " "+s.Email + " " +s.City);
            
            Console.ReadLine();
        }
    }
}






Structs:
----------
Structs can have:
    1. Private fields
    2. public properties
    3. constructors
    4. method
 just like a class



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Structs
{
    //here everything is same as in the class..only difference is we have used struct instead of class.
    public struct Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
        public Customer(int id, string name)
        {
            this._id = id;
            this._name = name;
        }
        public void PrintDetails()
        {
            Console.WriteLine("Id: {0} and Name: {1}", this._id, this._name);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Customer c1 = new Customer(101,"Mark");
            c1.PrintDetails();

            Customer c2 = new Customer();
            c2.ID = 102;
            c2.Name = "Jake";
            c2.PrintDetails();
            Console.ReadLine();

            //this is object initializer syntax (introduced in C# 3.0)...we can use this to intitialize classes as well
            Customer c3 = new Customer
            {
                ID=103,
                Name="Aman"
            };
            c3.PrintDetails();

        }
    }
}



DIFFERENCE BETWEEN CLASS AND STRUCT:
-------------------------------------

Struct is a value type while class is reference type.
structs are stored in stack while class are stored in heap

Value type hold their value in memory where they are declared, but reference types hold a reference to an object in memory.

Value types are destroyed immediately after the scope is lost while for the reference types only the reference variable is destroyed
after the scope is lost. Object is destroyed later by the garbage collector.

When you copy one struct into another struct, a new copy of that struct is created and modification on one struct will not affect the
values contained in other struct.
On the other hand if we copy a class to another class, we only get copy of the reference variable and both the reference variable point to 
the same object on heap. So any operation on one will affect the values contained by the other reference variable.

structs cannot have destructor while class can have destructor

Class:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

    public class Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
  
      
    }
    class Program
    {
        static void Main(string[] args)
        {

            
                Customer c1 = new Customer(); 
                c1.ID = 898;
                c1.Name = "Mark";
             

                Customer c2 = c1;
                c2.Name = "wala";
                Console.WriteLine("C1.Name: {0} and C2.Name: {1}", c1.Name, c2.Name);
                // this will refer to the same object and change in name will affect both c1 and c2
          }
            int k = i;
        Console.ReadLine();

        }
    }


On the other hand:

    public struct Customer
    {
        private int _id;
        private string _name;

        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        public int ID
        {
            get { return this._id; }
            set { this._id = value; }
        }
  
      
    }
    class Program
    {
        static void Main(string[] args)
        {

            
                Customer c1 = new Customer(); 
                c1.ID = 898;
                c1.Name = "Mark";
             

                Customer c2 = c1;
                c2.Name = "wala";
                Console.WriteLine("C1.Name: {0} and C2.Name: {1}", c1.Name, c2.Name);
                // this will refer to the different object and change in name will NOT affect both c1 and c2
          }
            int k = i;
         Console.ReadLine();

        }
    }
}

Structs cannot have explicit parameter less constructor where as class can.
this means:
in struct:


public struct Customer{
    public Customer(){} is not allowed while this is allowed in class
}
Struct cannot ih=nherit from another class where as class can can. Both class and structs can inherit from interface.
int, double are examples of structs in .NET framework. Struct are sealed types.

when we seal a class we cannot inherit from that.

public sealed class Customer{
    // some code
}
public class Derived : Customer is not allowed



Interface:
----------

keyword is interface. Just like classes interface also contains properties, methods, delegates or events but only declaration 
and no implementation.
They are public by default and they won't allow explicit modifiers.(Don't even put public keyword, they are public by default).
 A class  can inherit from multiple interface but not more than one class at a time. They cannot also contain field.
Interface can inherit from other interface.
We cannot insantiate from an interface but an interface reference variable can point to a derived class object.

We generally put I infront of a interface name as ICustomer.
When we implement the interface we need to put the access modifier as public.

Parent class reference variable can point to a child class object.


Explicit Interface Inplementation:
------------------------------------
Don't use the access modifiers in the explicit Inteface implementation. When two or more interface has same method signature
there will be confusion, this is the case of explicit interface implementation. and in this case we should not use the access modifier
in the interface implementation.

namespace ExplicitInterfaceImplementation
{
    interface I1
    {
        void Method1();
     }
    interface I2
    {
        void Method1();
    }
    class Program :I1,I2
    {
        void I1.Method1() // no access modifier
        {
            Console.WriteLine("I1 interface method");
        }

        void I2.Method1() // no access modifier
        {
            Console.WriteLine("I2 interface method");
        }
        static void Main(string[] args)
        {
            Program P = new Program();
            //P.Method1(); There is an ambuiguity it is invoking the I1 or I2's method
            ((I1)P).Method1(); // type casting is necessary
            ((I2)P).Method1();
            Console.ReadLine();
        }
    }
}


We can also set one interface default and other not default as:


namespace ExplicitInterfaceImplementation
{


    interface Inter
    {
        void Method2();
    }
    interface face
    {
        void Method2();
    }
    class Program :Inter,face
    {
        public void Method2()
        {
            Console.WriteLine("Default inteface method 2");
        }
        void face.Method2()
        {
            Console.WriteLine("Not so Default inteface method 2");
        }

        static void Main(string[] args)
        {
            Program P = new Program();
            P.Method2();
            ((face)P).Method2();

            Console.ReadLine();
        }
    }
}



Abstract Class in C#:
------------------------

Keyword: abstract
They are incomplete classes.Abstract methods will not have any implementation, just a signature as interface.
They cannot be instantiated. The class derived from the abstract classes has to be implemented by the child class.
Abstract classes are only used as a base classes.

If class inherits from the abstract from the abstract class, it has two options to implement the abstract method.
    1. provide implementation for all the abstract members inherited from the base abstract.
    2. If you do not wish to implement the abstract the methods, then the class has to be marked as abstract.


Abstract class cannot be sealed...sealed keyword to prevent inheriting...they contradit each other.
Absstract class may contain abstract method and fields, but not mandatory


Abstract Classes vs Interfaces:
-------------------------------

Abstract classes can have implementation of some of the members but none for interface.
Abstract classes can have fields but no for interface
Interface can inherit from another interface but not from abstract class while abstract can inherit from another
abstract class or interface.
A class can inherit from multiple interface at the same time while as class cannot from the multiple classes at the same time
Abstract class members can hava access modifier where as interface members (methods) cannot have access modifiers.


Problems with multiple Class inheritance:
------------------------------------------
Diamond problem.

Scenario:
There is a Base class A
B and C inherits from A
D inherits from B and C

                    A
            B               C
                    D

            then d will not know which method to implement, B's or D's

Gist : do not implement from the multiple class and it will also not allow that.


MultipleClass iheritance using the interfaces:
------------------------------------------------

Simple cha.. just do it.



Delegates in C#:
----------------
It is a type safe (signature should match) funtion pointer. It points to a function and when you call a the delgate, it invokes the function
Keyword: delegate
Syntax just like function....just like a method signature


using System;
using System.Collections.Generic;

namespace DelegatesInCSharp
{

    public delegate void HelloFunctionDelegate(string str);

    //this points to any method which has a void return type and take a string input
    class Program
    {
        static void Main(string[] args)
        {
            HelloFunctionDelegate del = new HelloFunctionDelegate(Hello); // we are passing in the name of the function pointer
            del("hello from delegate");
            Console.ReadLine();
        }

        public static void Hello(string str)
        {
            Console.WriteLine(str);
        }

     }
}

Why?
Delegates are similar to class, we can create an instance of it and when you do do, pass in the function name as a parameter to the 
delegate constructor and it is to this function the delegate will point to.


Delegate usage in C#:
--------------------


using System;
using System.Collections.Generic;


namespace DelegateUsage
{
    class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
        public int Experience { get; set;}

        public static void PromoteEmployee(List<Employee> employeeList)
        {
            foreach(Employee employee in employeeList){
                if(employee.Experience>=5){
                    Console.WriteLine(employee.Name+ " Promoted");
                }
            }
            
        }
        
    }
    class Program
    {
        static void Main(string[] args)
        {
            List<Employee> empList = new List<Employee>();
            empList.Add(new Employee(){ID=101,Name="Mary",Salary=5000,Experience=4});
            empList.Add(new Employee(){ID=102,Name="Jane",Salary=3000,Experience=5});
            empList.Add(new Employee(){ID=103,Name="Rob",Salary=5000,Experience=6});
            empList.Add(new Employee(){ID=104,Name="Percival",Salary=5000,Experience=2});
            empList.Add(new Employee(){ID=105,Name="Jon",Salary=7000,Experience=3});
            empList.Add(new Employee(){ID=106,Name="Dave",Salary=53000,Experience=7});
            empList.Add(new Employee(){ID=107,Name="Chris",Salary=5000,Experience=4});
            Employee.PromoteEmployee(empList);
            Console.ReadLine();

        }
    }
}
Problem with this code is it is hard coded, not flexible....with delegate we will make it flexible.


using System;
using System.Collections.Generic;


namespace DelegateUsage
{
    delegate bool IsPromotable(Employee empl);
    class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
        public int Experience { get; set;}

        public static void PromoteEmployee(List<Employee> employeeList, IsPromotable IsEligibleToPromote)
        {
            foreach(Employee employee in employeeList){
                if(IsEligibleToPromote(employee)){
                    Console.WriteLine(employee.Name+ " Promoted");
                }
            }
            
        }
             
    }
    class Program
    {
        static void Main(string[] args)
        {
            List<Employee> empList = new List<Employee>();
            empList.Add(new Employee(){ID=101,Name="Mary",Salary=5000,Experience=4});
            empList.Add(new Employee(){ID=102,Name="Jane",Salary=3000,Experience=5});
            empList.Add(new Employee(){ID=103,Name="Rob",Salary=5000,Experience=6});
            empList.Add(new Employee(){ID=104,Name="Percival",Salary=5000,Experience=2});
            empList.Add(new Employee(){ID=105,Name="Jon",Salary=7000,Experience=3});
            empList.Add(new Employee(){ID=106,Name="Dave",Salary=53000,Experience=7});
            empList.Add(new Employee(){ID=107,Name="Chris",Salary=5000,Experience=4});
            IsPromotable promotable = new IsPromotable(Promote);
                
            Employee.PromoteEmployee(empList,promotable);
            Console.ReadLine();

        }
 public static bool Promote(Employee emp)
        {
            if (emp.Experience >= 5)
            {
                return true;
            }
            else
                return false;
        }
    }
}


MultiCast Delegates:
----------------------

It is a delegate that has reference to more than one function. When you invoke the multicast delegate, all the functions the delegate
is pointing, are invoked.
2 approches:
    + or += to register a method with the delegate
    - or -= to unregister a method with the delegate

It invokes in the same order  in which they are added.
Multicast delegate are used in the  implementation of the observer design pattern and it is also called as publish/subsribe pattern.

If the delegate has a return type other than void and if the delegate is a multicast delegate, only the value of the last invoked method
will be returned. Along the same lines, if he delegate has an out parameter, the value of the output parameter, will be the value assigned by the last
method.

namespace MultiCastDelegates
{
    public delegate void SampleDelegate();
    class Program
    {
        public static void SampleMethod1()
        {
            Console.WriteLine("Sample method 1 Invoked");
        }
        public static void SampleMethod2()
        {
            Console.WriteLine("Sample method 2 Invoked");
        }
        public static void SampleMethod3()
        {
            Console.WriteLine("Sample method 3 Invoked");
        }
     
        static void Main(string[] args)
        {
            SampleDelegate del1, del2, del3, del4;
            del1 = new SampleDelegate(SampleMethod1);
            del2 = new SampleDelegate(SampleMethod2);
            del3 = new SampleDelegate(SampleMethod3);
     //     del4 = del1 + del2 + del3; //del4 is pointing to all sampleMethod1, sampleMethod2, sampleMethod3
            del4 = del1 + del2 + del3-del2;  // this will add the del2 and then removes the del2 again.
            del4();
            
            
            // Other way to use the multicast the delegate
            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            del += SampleMethod3;
            //del -= SampleMethod1;
            del();


            Console.ReadLine();
        }
    }
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MultiCastDelegates
{
    public delegate int SampleDelegate();
    class Program
    {
        public static void SampleMethod1()
        {
            
            Console.WriteLine("Sample method 1 Invoked");
            return 1;
            
        }
        public static int SampleMethod2()
        {
            Console.WriteLine("Sample method 2 Invoked");
            return 2;
        }
      
        static void Main(string[] args)
        {

            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            int  DelegateReturnedValue = del(); // it hold the value from the last invokation list
            Console.WriteLine(DelegateReturnedValue);


            Console.ReadLine();
        }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MultiCastDelegates
{
    public delegate void SampleDelegate(out int Integer);
    class Program
    {
        public static void SampleMethod1(out int num)
        {
            num = 1;
            Console.WriteLine("Sample method 1 Invoked");
            
        }
        public static void SampleMethod2(out int num)
        {
            num = 2;
            Console.WriteLine("Sample method 2 Invoked");
            
        }
      
        static void Main(string[] args)
        {

            SampleDelegate del = new SampleDelegate(SampleMethod1);
            del += SampleMethod2;
            int  DelegateOutparameterValue = -1;
            del(out DelegateOutparameterValue);
            Console.WriteLine(DelegateOutparameterValue);
            Console.ReadLine();
        }
    }
}

